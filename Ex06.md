# Ex. No : 6	
# IMPLEMENTATION OF THE BACK END OF THE COMPILER 
## Register Number : 212223040190
## Date : 20-11-25

## AIM   
To write a program to implement the back end of the compiler.

## ALGORITHM
1.	Start the program.
2.	Get the three variables from statements and stored in the text file k.txt.
3.	Compile the program and give the path of the source file.
4.	Execute the program.
5.	Target code for the given statement is produced.
6.	Stop the program.

## PROGRAM
backend.c
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

/* simple backend: read lines like "X=a-b" or "X = a - b" and emit:
   Statement           Target Code
   X=a-b               MOV a,R0
                       SUB b,R0
                       MOV R0,X
*/
static void trim(char *s) {
    /* trim leading/trailing whitespace in place */
    char *p = s;
    while (isspace((unsigned char)*p)) p++;
    if (p != s) memmove(s, p, strlen(p)+1);
    size_t len = strlen(s);
    while (len > 0 && isspace((unsigned char)s[len-1])) s[--len] = '\0';
}

int main(int argc, char **argv) {
    char filename[260];
    if (argc > 1) {
        strncpy(filename, argv[1], sizeof(filename)-1);
        filename[sizeof(filename)-1] = '\0';
    } else {
        printf("Enter the filename of the intermediate code: ");
        if (scanf("%259s", filename) != 1) return 1;
    }

    FILE *fp = fopen(filename, "r");
    if (!fp) {
        fprintf(stderr, "Error opening file '%s'\n", filename);
        return 1;
    }

    char line[512];
    int reg = 0;
    printf("Statement\t\tTarget Code\n");
    printf("---------\t\t-----------\n");

    while (fgets(line, sizeof(line), fp)) {
        /* remove newline and trim */
        trim(line);
        if (line[0] == '\0') continue;

        /* keep original statement for printing */
        char stmt[512];
        strncpy(stmt, line, sizeof(stmt)-1);
        stmt[sizeof(stmt)-1] = '\0';

        /* parse: expect LHS = op1 operator op2 */
        char *eq = strchr(line, '=');
        if (!eq) {
            printf("%s\t\t/* skipped: no '=' */\n", stmt);
            continue;
        }
        *eq = '\0';
        char lhs[64], rhs[512];
        strncpy(lhs, line, sizeof(lhs)-1); lhs[sizeof(lhs)-1] = '\0';
        strncpy(rhs, eq + 1, sizeof(rhs)-1); rhs[sizeof(rhs)-1] = '\0';
        trim(lhs); trim(rhs);

        /* find operator + or - or * or / */
        char op = 0;
        char *oppos = NULL;
        for (char *p = rhs; *p; ++p) {
            if (*p == '+' || *p == '-' || *p == '*' || *p == '/') {
                op = *p;
                oppos = p;
                break;
            }
        }

        char op1[128] = {0}, op2[128] = {0};
        if (op && oppos) {
            /* split around operator */
            *oppos = '\0';
            strncpy(op1, rhs, sizeof(op1)-1);
            strncpy(op2, oppos + 1, sizeof(op2)-1);
            trim(op1); trim(op2);
        } else {
            /* assignment without binary operator (e.g., X = a) */
            strncpy(op1, rhs, sizeof(op1)-1);
            trim(op1);
            op = 0;
        }

        /* emit code */
        int thisReg = reg++;
        /* if no operator, just MOV op1,R then MOV R,lhs (or MOV op1,lhs) */
        if (!op) {
            /* direct move into register and then to LHS for uniformity */
            printf("%s\tMOV %s,R%d\n\tMOV R%d,%s\n", stmt, op1, thisReg, thisReg, lhs);
        } else {
            /* MOV op1,Rn  ; apply op with op2 on Rn  ; MOV Rn,LHS */
            const char *opname = (op == '+') ? "ADD" : (op == '-') ? "SUB"
                                 : (op == '*') ? "MUL" : "DIV";
            printf("%s\tMOV %s,R%d\n", stmt, op1, thisReg);
            printf("\t%s %s,R%d\n", opname, op2, thisReg);
            printf("\tMOV R%d,%s\n", thisReg, lhs);
        }
    }

    fclose(fp);
    return 0;
}
```
k.txt
```
X=a-b
Y=a-c
Z=a+b
C=a-b
C=a-b
```
## OUTPUT 
<img width="759" height="520" alt="Screenshot 2025-11-18 014645" src="https://github.com/user-attachments/assets/b1306041-1d4f-4a10-8e9b-4f24fc5a196f" />

## RESULT
The back end of the compiler is implemented successfully, and the output is verified.
